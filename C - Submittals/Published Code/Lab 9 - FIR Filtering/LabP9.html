
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Lab P-9 - Sampling, Convolution, and FIR Filtering: 3 Lab Exercises (FIR Filters)</title><meta name="generator" content="MATLAB 9.12"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-04-16"><meta name="DC.source" content="LabP9.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Lab P-9 - Sampling, Convolution, and FIR Filtering: 3 Lab Exercises (FIR Filters)</h1><!--introduction--><p>In the following sections we will study how a filter can produce the following special effects: 1)Echo; 2)Deconvolution</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">3.1 Deconvolution Experiment for 1-D Filters</a></li><li><a href="#2">3.1.1 Restoration Filter</a></li><li><a href="#3">3.1.2 Worst Case Error</a></li><li><a href="#4">3.1.3 An Echo Filter</a></li><li><a href="#5">3.2 Cascading Two Systems</a></li><li><a href="#6">3.2.1 Overall Impulse Response</a></li><li><a href="#7">3.2.2 Distorting and Restoring Images</a></li><li><a href="#8">3.2.3 A Second Restoration Experiment</a></li></ul></div><h2 id="1">3.1 Deconvolution Experiment for 1-D Filters</h2><p>Use the function firfilt() to implement the filter <img src="LabP9_eq01793735894433794592.png" alt="$$w[n]=x[n]-0.9x[n-1]$" style="width:158px;height:15px;"> (3) on the input signal x[n] defined.</p><pre class="codeinput">clear; <span class="comment">%&lt;--clear workspace</span>
close <span class="string">all</span> <span class="comment">%&lt;--close all figures</span>

<span class="comment">% Input signal</span>
xx=255*(rem(0:100,50)&lt;10);
<span class="comment">% Filter coefficient</span>
bb=[1 -0.9];
<span class="comment">% Compute the output - FIR Filter-1</span>
ww=firfilt(bb,xx);

<span class="comment">% 3.1a)********************************************************************</span>
<span class="comment">% Plot both the input and output wave forms x[n] and w[n] on the same</span>
<span class="comment">% figure, using subplot. Explain why the output appears the way it does by</span>
<span class="comment">% figuring out (mathematically) the effect of the filter coefficient.</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Array Indices</span>
first=1;
last=length(xx);
nn=first:last; <span class="comment">%&lt;-- use first=1 and last=length(xx)</span>

<span class="comment">% Plots</span>
figure(1)
subplot(2,1,1);
stem(first-1:last-1,xx(nn),<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'Input x[n]'</span>,<span class="string">'FontSize'</span>,16);
title(<span class="string">'3.1a)Deconv Experiment for 1-D Filters'</span>,<span class="string">'FontSize'</span>,16);
xlim([0 75]);
subplot(2,1,2);
stem(first-1:last-1,ww(nn),<span class="string">'filled'</span>,<span class="string">'LineWidth'</span>,2) <span class="comment">%--Make black dots</span>
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'Output w[n]'</span>,<span class="string">'FontSize'</span>,16);
xlim([0 75]);


<span class="comment">% Analysis of results:</span>
<span class="comment">% Through the coefficient bb, the process (mathematically) of the filter is</span>
<span class="comment">% w[n]= x[n]&#8722;0.9*x[n &#8722; 1].</span>
<span class="comment">% w[0]= x[0]&#8722;0.9*x[n&#8722;1]=255&#8722;0= 255;</span>
<span class="comment">% w[1]= x[1]&#8722;0.9*x[0]=255&#8722;0.9*(255)=25.5</span>
<span class="comment">% w[2:9]=w[1]=25.5</span>
<span class="comment">% w[10]= x[10]&#8722;0.9*x[9]=0-0.9*(255)=-229.5;</span>
<span class="comment">% w[11]= x[11]&#8722;0.9*x[10]=0-0.9*(0)=0;</span>
<span class="comment">% w[12:49]= w[11]=0;</span>
<span class="comment">% Then it starts over as w[0]= 255;</span>
<span class="comment">% Initially, the output of the filter is at 255 and it suddenly declines to</span>
<span class="comment">% 25.5 and stay constant till n=10. Moreover, the output go down negative</span>
<span class="comment">% and then up to zero.</span>

<span class="comment">% 3.1b)********************************************************************</span>
<span class="comment">% Note that w[n] and x[n] are not the same length. Determine the length of</span>
<span class="comment">% the filtered signal w[n], and explain how it is related to the length of</span>
<span class="comment">% x[n] and the length of the FIR filter. (If you need a hint, refer ro</span>
<span class="comment">% section 1.2.)</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Calculation</span>
length_x_n=length(xx);
length_w_n=length(ww);

<span class="comment">% Message Box with results</span>
msgbox(sprintf(<span class="string">'Total Length of x[n] = %0.5g \nTotal Length of w[n] = %0.5g'</span><span class="keyword">...</span>
    ,length_x_n,length_w_n),<span class="string">'3.1b)'</span>)

<span class="comment">% Analysis of results:</span>
<span class="comment">% Section 1.2 shows that length(yy) = length(xx)+length(bb)-1,</span>
<span class="comment">% Thus, length(ww) = length(xx)+ length(bb)-1</span>
</pre><img vspace="5" hspace="5" src="LabP9_01.png" alt=""> <img vspace="5" hspace="5" src="LabP9_02.png" alt=""> <h2 id="2">3.1.1 Restoration Filter</h2><p>The filter <img src="LabP9_eq12714225792964154802.png" alt="$$y[n]=\sum_{l=0}^{M}r^lw[n-l]$" style="width:127px;height:44px;"> (FIR Filter-2) can be used to undo the effects of the FIR filter in the previous section. Use the following steps to show how well it works when r=0.9 and M=22.</p><pre class="codeinput"><span class="comment">% 3.1.1a)******************************************************************</span>
<span class="comment">% Process the signal w[n] from (3) with FILTER-2 to obtain the output</span>
<span class="comment">% signal y[n]</span>
<span class="comment">%**************************************************************************</span>

close <span class="string">all</span> <span class="comment">%&lt;--close all figures</span>

<span class="comment">% FIR Filter-2 Variables</span>
r=0.9; M=22;
<span class="comment">% signal y[n]</span>
yy=zeros(length(xx),1);

<span class="comment">% Compute the output - FIR Filter-2</span>
yy=firfilt2(ww,yy,r,M);

<span class="comment">% 3.1.1b)******************************************************************</span>
<span class="comment">% Make stem plots of w[n] and y[n] using a time-index axis n that is the</span>
<span class="comment">% same for both signals. Put the stem plot in the same window for</span>
<span class="comment">% comparison - using a two-panel subplot.</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Plots</span>
figure(2)
subplot(2,1,1);
stem(first-1:last-1,ww(nn),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'Output w[n]'</span>,<span class="string">'FontSize'</span>,16);
title(<span class="string">'3.1.1b) Restoration Filter'</span>,<span class="string">'FontSize'</span>,16);
xlim([0 49]);
hold <span class="string">on</span>
subplot(2,1,2);
stem(first-1:last-1,yy(nn),<span class="string">'r'</span>,<span class="string">'filled'</span>,<span class="string">'LineWidth'</span>,2) <span class="comment">%--Make black dots</span>
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'y[n] (Restoring x[n])'</span>,<span class="string">'FontSize'</span>,16);
xlim([0 49]);
ylim([min(ww) max(xx)]);
hold <span class="string">off</span>

<span class="comment">% 3.1.1c)******************************************************************</span>
<span class="comment">% Since the objective of the restoration is to produce y[n] that is almost</span>
<span class="comment">% identical to x[n], make a plot of the error (difference) between x[n] and</span>
<span class="comment">% y[n] over the range 0&lt;=n&lt;50</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Calculate Error between x[n] and y[n]</span>
error=abs(yy-xx);

<span class="comment">% Plots</span>
figure(3)
subplot(2,1,1);
stem(first-1:last-1,xx(nn),<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,2)
hold <span class="string">on</span>
stem(first-1:last-1,yy(nn),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'x[n] and y[n]'</span>,<span class="string">'FontSize'</span>,16);
xlim([0 50]);
title(<span class="string">'3.1.1c) Absolute Error between x[n] and y[n]'</span>,<span class="string">'FontSize'</span>,16);
legend(<span class="string">'x[n]'</span>,<span class="string">'y[n]'</span>)
subplot(2,1,2);
plot(first-1:last-1,error,<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'\miderror\mid'</span>,<span class="string">'FontSize'</span>,16);
xlim([0 50]);
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="LabP9_03.png" alt=""> <img vspace="5" hspace="5" src="LabP9_04.png" alt=""> <h2 id="3">3.1.2 Worst Case Error</h2><pre class="codeinput"><span class="comment">% 3.1.2a)******************************************************************</span>
<span class="comment">% Evaluate the worst-case error by doing the following: use max() function</span>
<span class="comment">% to find the maximum of the difference between y[n] and x[n] in the range</span>
<span class="comment">% 0 &lt;= n &lt; 50.</span>
<span class="comment">%**************************************************************************</span>

close <span class="string">all</span> <span class="comment">%&lt;--close all figures</span>

<span class="comment">% Calculate worst-case error</span>
wrst_error=max(error(1:51)) ;

<span class="comment">% Message Box with results</span>
msgbox(sprintf(<span class="string">'WRST Error between y[n] &amp; w[n] = %0.5g'</span><span class="keyword">...</span>
    ,wrst_error),<span class="string">'3.1.2)'</span>)



<span class="comment">% 3.1.2b)******************************************************************</span>
<span class="comment">% What does the error plot and worst case error tell you about the quality</span>
<span class="comment">% of the restoration of x[n]? How small do you think the worst case error</span>
<span class="comment">% has to be so that it cannot be seen on a plot?</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Analysis of results:</span>
<span class="comment">% The max difference between x[n] and a y[n] is 22.6 (11.24%), which shows</span>
<span class="comment">% a mild lack of restoration quality. The output range is 0&#8722;256, which it</span>
<span class="comment">% shows the error is comparatively small. This displays that output y[n]</span>
<span class="comment">% is a good restoration of the input x[n]. A worst-case error less than 0.1</span>
<span class="comment">% % would be ideal and hard to spot in the plot.</span>
</pre><img vspace="5" hspace="5" src="LabP9_05.png" alt=""> <h2 id="4">3.1.3 An Echo Filter</h2><p>The following FIR filter can be interpreted as an echo filter. <img src="LabP9_eq16143663686712744464.png" alt="$$y1[n]=x1[n]+r*x1[n-P]$" style="width:183px;height:15px;"> (4). Explain why this is a valid interpretation by working out the following:</p><pre class="codeinput"><span class="comment">% 3.1.3a)******************************************************************</span>
<span class="comment">% You have an audio signal sampled at fs = 8000 Hz and you would like to</span>
<span class="comment">% add a delayed version of the signal to simulate an echo. The time delay</span>
<span class="comment">% of the echo should be 0.2 seconds, and the strength of the echo should be</span>
<span class="comment">% 90% percent of the original. Determine the values of r and P in (4); make</span>
<span class="comment">% P an integer.</span>
<span class="comment">%**************************************************************************</span>

close <span class="string">all</span> <span class="comment">%&lt;--close all figures</span>

<span class="comment">% Frequency the audio signal is sampled</span>
fs=8000; <span class="comment">%&lt;--Hz</span>
<span class="comment">% Time Delay</span>
delay=0.2;  <span class="comment">%&lt;--s</span>

<span class="comment">% Calculations of P and r</span>
Ts=1/fs;
P=delay/Ts;
r=0.9;

<span class="comment">% 3.1.3b)******************************************************************</span>
<span class="comment">% Describe the filter coefficients of this FIR filter, and determine its</span>
<span class="comment">% length.</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% FIR filter coefficient</span>
bb2=[1; zeros(P-2,1); r]';
<span class="comment">% FIR filter length</span>
length_FIR=length(bb2);
<span class="comment">% Message Box with results</span>
msgbox(sprintf(<span class="string">'FIR Filter coefficients are shown on Matlab code \nlength_FIR = %0.5g '</span><span class="keyword">...</span>
    ,length_FIR),<span class="string">'3.1.3b)'</span>)

<span class="comment">% 3.1.3c)******************************************************************</span>
<span class="comment">% Implement the echo filter in (4) with the values of r and P determined in</span>
<span class="comment">% part (a). Use the speech signal in the vector x2 found in the file</span>
<span class="comment">% labdat.mat. Listen to the result to verify that you have produced an</span>
<span class="comment">% audible echo.</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% BELOW SECTION HAS BEEN COMMENTED OUT FOR PUBLISHING PURPOSE.</span>
<span class="comment">% % Load file labdat.mat to get speech signal x2</span>
<span class="comment">% load labdat;</span>
<span class="comment">% % Compute the output - FIR Filter (4) - Audio with Echo</span>
<span class="comment">% y1=firfilt(bb2,x2);</span>
<span class="comment">% % Listen to Original Audio</span>
<span class="comment">% waitfor(msgbox("Click 'OK' to listen to Original Speech Audio","3.1.3c)"))</span>
<span class="comment">% sound(x2)</span>
<span class="comment">% pause(4)</span>
<span class="comment">% % Listen to Audio with Echo</span>
<span class="comment">% waitfor(msgbox("Click 'OK' to listen to Speech Audio with Ech..." + ...</span>
<span class="comment">%     "o - created... with FIR Filter (4)","3.1.3c)"))</span>
<span class="comment">% % pause</span>
<span class="comment">% sound(y1)</span>
</pre><img vspace="5" hspace="5" src="LabP9_06.png" alt=""> <h2 id="5">3.2 Cascading Two Systems</h2><p>More complicated systems are often made up from simple building blocks. In the system of Fig 3. two FIR filters are connected "in cascade". For this session, assume that the filters in Fig. 3 are described by the two equations: <img src="LabP9_eq00811896100179741949.png" alt="$$w[n]=x[n]-q*x[n-1]$" style="width:161px;height:15px;"> (FIR Filter-1) , <img src="LabP9_eq12714225792964154802.png" alt="$$y[n]=\sum_{l=0}^{M}r^lw[n-l]$" style="width:127px;height:44px;"> (FIR Filter-2)</p><h2 id="6">3.2.1 Overall Impulse Response</h2><pre class="codeinput"><span class="comment">% 3.2.1a)******************************************************************</span>
<span class="comment">% (a)	Implement the system in Fig. 3 using MATLAB to get the impulse</span>
<span class="comment">% response of the overall cascaded system for the case where q = 0.9, r =</span>
<span class="comment">% 0.9 and M = 22. Use two calls to firfilt(). Plot the impulse response of</span>
<span class="comment">% the overall cascaded system.</span>
<span class="comment">%**************************************************************************</span>

clear; <span class="comment">%&lt;--clear workspace</span>
close <span class="string">all</span> <span class="comment">%&lt;--close all figures</span>

<span class="comment">% Overall Impulse Response - Variables</span>
xx=zeros(51,1); <span class="comment">%&lt;--Input Array</span>
xx(1)=1; <span class="comment">%&lt;--Impulse</span>
hh=zeros(length(xx),1); <span class="comment">%&lt;--Impulse Response</span>
<span class="comment">% Filter Filter-1 Coef.</span>
bb=[1 -0.9];
<span class="comment">% FIR Filter-2 Variables</span>
r=0.9; M=22;

<span class="comment">% Impulse response of the System</span>
hh=firfilt2(firfilt(bb,xx),hh,r,M);

<span class="comment">% Array Indices</span>
first=1;
last=length(xx);
nn=first:last; <span class="comment">%&lt;-- use first=1 and last=length(xx)</span>

<span class="comment">% Plots</span>
figure(4)
stem(first-1:last-1,hh(nn),<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'Impulse Response h[n]'</span>,<span class="string">'FontSize'</span>,16);
title(<span class="string">'3.2.1a)Overall Impulse Response, M=22'</span>,<span class="string">'FontSize'</span>,16);

<span class="comment">% 3.2.1b)******************************************************************</span>
<span class="comment">% Work out the impulse response h(n) of the cascaded system by hand to</span>
<span class="comment">% verify that your MATLAB result in part (a) is correct. (Hint: consult old</span>
<span class="comment">% Homework problems.)</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Verification of the Results</span>
<span class="comment">%w[0]=x[0]-0.9x[0-1]=1</span>
<span class="comment">%w[1]=x[1]-0.9x[0]=-0.9</span>
<span class="comment">%w[2]=x[2]-0.9x[1]=0</span>
<span class="comment">%w[3]=x[3]-0.9x[2]=0</span>
<span class="comment">%.</span>
<span class="comment">%.</span>
<span class="comment">%.</span>
<span class="comment">%w[22]=x[22]-0.9w[21]=0</span>
<span class="comment">%</span>
<span class="comment">%y[0]=0.9^0w[0]+0.9^1w[-1]+0.9^2w[-2]+0.9^3w[-3]+...+0.9^22w[-22]=1</span>
<span class="comment">%y[1]=0.9^0w[1]+0.9^1w[0]+0.9^2w[-1]+0.9^3w[-2]+...+0.9^22w[-21]=0</span>
<span class="comment">%y[2]=0.9^0w[2}+0.9^1w[1]+0.9^2w[0]+0.9^3w[-1]+...+0.9^22w[-20]=0</span>
<span class="comment">%y[3]=0.9^0w[3]+0.9^1w[2]+0.9^2w[1]+0.9^3w[0]+...+0.9^22w[-19]=0</span>
<span class="comment">%.</span>
<span class="comment">%.</span>
<span class="comment">%.</span>
<span class="comment">%y[22]=0.9^0w[22]+0.9^1w[21]+0.9^2w[20]+...0.9^21w[1]+0.9^22w[0]=0</span>
<span class="comment">%y[23]=0.9^0w[23]+0.9^1w[22]+0.9^2w[21]+0.9^3w[20]+...+0.9^22w[1]=-0.088629</span>
<span class="comment">%y[24]=0.9^0w[24]+0.9^1w[23]+0.9^2w[23]+0.9^3w[21]+...+0.9^22w[2]=0</span>
<span class="comment">%y[25]=0</span>
<span class="comment">%y[26]=0</span>
<span class="comment">%.</span>
<span class="comment">%.</span>
<span class="comment">%.</span>
<span class="comment">%As we can see the numbers match with our MATLAB result.</span>

<span class="comment">% 3.2.1c)******************************************************************</span>
<span class="comment">% In a deconvolution application, the second system (FIR FILTER-2) tries to</span>
<span class="comment">% undo the convolutional effect of the first. Perfect deconvolution would</span>
<span class="comment">% require that the cascade combination of the two systems be equivalent to</span>
<span class="comment">% the identity system: y[n]=x[n]. If the impulse responses of the two</span>
<span class="comment">% systems are h1(n)and h2(n), state the condition on h1[n]*h2[n] to</span>
<span class="comment">% achieve perfect deconvolution.</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Analysis</span>
<span class="comment">% Deconvolution is the process of filtering a signal to compensate for an</span>
<span class="comment">% undesired convolution. Undesired convolution can be: blurried images</span>
<span class="comment">% (ghosts), echoes in audio, etc.</span>
<span class="comment">% In our case here, to achieve perfect deconvolution y[n]=x[n]. To extract</span>
<span class="comment">% the original signal, the deconvolution filter (FIR FILTER-2) must undo</span>
<span class="comment">% the amplitude and phase changes caused by FIR FILTER-1. Thus, the whole</span>
<span class="comment">% system, which includes FIR FILTER-1 AND FIR FILTER-2 in cascade, would</span>
<span class="comment">% have no overall effect on the input. What that mean is that h1[n]*h2[n]</span>
<span class="comment">% needs to be equals to DELTA for that to be true. Theoretically, this can</span>
<span class="comment">% be achieved if the right coefficients in each filter are adequate,</span>
<span class="comment">% however this becomes not so realistic in real world application since</span>
<span class="comment">% there are always unknowns such as electronic noise, temperature drift, or</span>
<span class="comment">% variation between devices.</span>
</pre><img vspace="5" hspace="5" src="LabP9_07.png" alt=""> <h2 id="7">3.2.2 Distorting and Restoring Images</h2><p>If we pick 'q' to be a little less than 1.0, then the first system (FIR FILTER-1) will cause distortion when applied to the rows and columns of an image. The objective in this section is to show that we can use the second system (FIR FILTER-2) to undo this distortion (more or less). Since FIR FILTER-2 will try to undo the convolutional effect of the first, it acts as a deconvolution operator.</p><pre class="codeinput"><span class="comment">% 3.2.2a)******************************************************************</span>
<span class="comment">% Load in the image echart.mat with the load command. It creates a matrix</span>
<span class="comment">% called echart.</span>
<span class="comment">%**************************************************************************</span>

close <span class="string">all</span> <span class="comment">%&lt;--close all figures</span>

<span class="comment">% Load image echart.mat</span>
load <span class="string">echart.mat</span>;

<span class="comment">% 3.2.2b)******************************************************************</span>
<span class="comment">% Pick q=0:9 in FILTER-1 and filter the image echart in both directions:</span>
<span class="comment">% apply FILTER-1 along the horizontal direction and then filter the</span>
<span class="comment">% resulting image along the vertical direction also with FILTER-1. Call the</span>
<span class="comment">% result ech90.</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Distorting and Restoring Images Variables</span>
ech90=zeros(length(echart));
<span class="comment">% FIR Filter-1 coefficient</span>
bb=[1 -0.9];

<span class="comment">% Applying FIR Filter-1</span>
<span class="keyword">for</span> i=1:length(ech90)
ech90(i,:)=firfilt(bb,echart(i,:));
<span class="keyword">end</span>


<span class="comment">% 3.2.2c)******************************************************************</span>
<span class="comment">% Deconvolve ech90 with FIR FILTER-2, choosing M = 22 and r = 0.9. Describe</span>
<span class="comment">% the visual appearance of the output, and explain its features by invoking</span>
<span class="comment">% your mathematical understanding of the cascade filtering process. Explain</span>
<span class="comment">% why you see &#8220;ghosts&#8221; in the output image, and use some previous</span>
<span class="comment">% calculations to determine how big the ghosts (or echoes) are, and where</span>
<span class="comment">% they are located. Evaluate the worst-case error in order to say how big</span>
<span class="comment">% the ghosts are relative to &#8220;black-white&#8221; transitions which are 0 to 255.</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Distorting and Restoring Images Variables</span>
[m,n]=size(echart);
rest_ech90=zeros(m,n);
<span class="comment">% FIR Filter-2 Variables</span>
r=0.9; M=22;

<span class="comment">% Applying FIR Filter-2 (Restoring)</span>
<span class="keyword">for</span> i=1:length(ech90)
rest_ech90(i,:)=firfilt2(ech90(i,:),rest_ech90(i,:),r,M);
<span class="keyword">end</span>

<span class="comment">% Check Image Processing</span>
figure(5)
subplot(1,3,1)
imshow(echart,[])
title(<span class="string">'Original Image'</span>)
subplot(1,3,2)
imshow(ech90,[])
title(<span class="string">'After FIR-1 '</span>)
subplot(1,3,3)
imshow(rest_ech90,[])
title(<span class="string">'After FIR-2 - Restored Image, M=22'</span>)
sgtitle(<span class="string">"Image processing - Figure 3"</span>,<span class="string">'FontSize'</span>,16);

<span class="comment">% Analysis of results:</span>
<span class="comment">% Looking at the restored image, we conclude that it has plausible been</span>
<span class="comment">% restored, however it presents "ghosts/echoes". The reason of the echoes</span>
<span class="comment">% can be explained looking at the impulse response of the whole system.</span>
<span class="comment">% The impulse response is echoed after n=23, with a value of -0.089. This</span>
<span class="comment">% corresponds to -8.9% in the gray scale [0 - 255].</span>
<span class="comment">% In the gray scaled image, we can predict the worst error (with a FIR Filter-2 (M=22)</span>
<span class="comment">% to be 255*8.86294% = 22.6. Furthermore, each pixel will echo with</span>
<span class="comment">% -8.86% of the pixel value [0 - 255] at n=23 forward.</span>
<span class="comment">% Later on on the lab, we will see the influence of varying the value of FIR</span>
<span class="comment">% Filter-2 'M' variable.</span>
</pre><img vspace="5" hspace="5" src="LabP9_08.png" alt=""> <h2 id="8">3.2.3 A Second Restoration Experiment</h2><pre class="codeinput"><span class="comment">% 3.2.3a)******************************************************************</span>
<span class="comment">% Now try to deconvolve ech90 with several different FIR filters for</span>
<span class="comment">% FILTER-2. You should set r = 0:9 and try several values for M such as 11,</span>
<span class="comment">% 22 and 33. Pick the best result and explain why it is the best. Describe</span>
<span class="comment">% the visual appearance of the output, and explain its features by invoking</span>
<span class="comment">% your mathematical understanding of the cascade filtering process. HINT:</span>
<span class="comment">% determine the impulse response of the cascaded system and relate it to</span>
<span class="comment">% the visual appearance of the output image. Hint: you can use dconvdemo to</span>
<span class="comment">% generate the impulse responses of the cascaded systems, like you did in</span>
<span class="comment">% the Warm-up.</span>
<span class="comment">%**************************************************************************</span>

close <span class="string">all</span> <span class="comment">%&lt;--close all figures</span>

<span class="comment">% A second restoration experiment variables</span>
rest_ech90_2=zeros(m,n); <span class="comment">% &lt;--Restoration Array 2 (M2=11)</span>
rest_ech90_3=zeros(m,n); <span class="comment">% &lt;--Restoration Array 3 (M3=33)</span>
hh2=zeros(length(xx),1);hh3=zeros(length(xx),1);<span class="comment">%&lt;--Impulse Response Arrays</span>
<span class="comment">% FIR Filter-2 Variables (different tests)</span>
r=0.9; M2=11; M3=33;

<span class="comment">% Applying FIR Filter-2, M=11 (Restoring)</span>
<span class="keyword">for</span> i=1:length(ech90)
rest_ech90_2(i,:)=firfilt2(ech90(i,:),rest_ech90_2(i,:),r,M2);
rest_ech90_3(i,:)=firfilt2(ech90(i,:),rest_ech90_3(i,:),r,M3);
<span class="keyword">end</span>

figure(6)
subplot(1,3,1)
imshow(rest_ech90_2,[])
title(<span class="string">'Restored Image, M=11'</span>)
subplot(1,3,2)
imshow(rest_ech90,[])
title(<span class="string">'Restored Image, M=22'</span>)
subplot(1,3,3)
imshow(rest_ech90_3,[])
title(<span class="string">'Restored Image,M=33'</span>)
sgtitle(<span class="string">"Restored images with different M values(FIR Filter-2)"</span>,<span class="string">'FontSize'</span>,16);


<span class="comment">% Analysis of results:</span>
<span class="comment">% It is clear that the best restoration happens when we choose a higher M,</span>
<span class="comment">% M=33. With a higher M, there are more # of summations for each FIR</span>
<span class="comment">% FILTER-2 output calculation. This minimizes the worst error (pixel</span>
<span class="comment">% comparisson between original and restored images). It is also predictable</span>
<span class="comment">% that the higher the M is, the higher echoed delay the image will have. We</span>
<span class="comment">% check this from the impulse response of the system with different 'M'</span>
<span class="comment">% values.</span>
<span class="comment">% Let's analyze the impulse response  in each case to prove</span>
<span class="comment">% the concept, when:</span>
<span class="comment">% I) M=11</span>
<span class="comment">% II) M=33.</span>


<span class="comment">% Impulse response of the Systems</span>
hh2=firfilt2(firfilt(bb,xx),hh2,r,M2);
hh3=firfilt2(firfilt(bb,xx),hh3,r,M3);

<span class="comment">% Array Indices</span>
first=1;
last=length(xx);
nn=first:last; <span class="comment">%&lt;-- use first=1 and last=length(xx)</span>

<span class="comment">% Plots</span>
figure(7)
subplot(3,1,1)
stem(first-1:last-1,hh2(nn),<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'h[n], M=11'</span>,<span class="string">'FontSize'</span>,16);
<span class="comment">% xlim([0 25]);</span>
title([<span class="string">'3.2.3a) Imp Response - different M values'</span> <span class="keyword">...</span>
    <span class="string">'(FIR-Filter-2)'</span>],<span class="string">'FontSize'</span>,16);
legend(<span class="string">'M=11'</span>);
subplot(3,1,2)
stem(first-1:last-1,hh(nn),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'h[n], M=22'</span>,<span class="string">'FontSize'</span>,16);
<span class="comment">% xlim([0 25]);</span>
legend(<span class="string">'M=22'</span>);
subplot(3,1,3)
stem(first-1:last-1,hh3(nn),<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,2)
xlabel(<span class="string">'Time Index (n)'</span>,<span class="string">'FontSize'</span>,16);
ylabel(<span class="string">'h[n], M=33'</span>,<span class="string">'FontSize'</span>,16);
<span class="comment">% xlim([0 25]);</span>
legend(<span class="string">'M=33'</span>);

<span class="comment">% 3.2.3b)******************************************************************</span>
<span class="comment">% Furthermore, when you consider that a gray-scale display has 256 levels,</span>
<span class="comment">% how large is the worst-case error (from the previous part) in terms of</span>
<span class="comment">% number of gray levels? Do this calculation for each of the three filters</span>
<span class="comment">% in part (a). Think about the following question: &#8220;Can your eyes perceive</span>
<span class="comment">% a gray scale change of one level, i.e., one part in 256?&#8221;</span>
<span class="comment">%**************************************************************************</span>

<span class="comment">% Calculation of worst cases</span>

<span class="comment">% Worst-case error when M=11</span>
error1=echart-rest_ech90_2;
wrst_error1=max(error1,[],<span class="string">'all'</span>);
<span class="comment">% Worst-case error when M=22</span>
error2=echart-rest_ech90;
wrst_error2=max(error2,[],<span class="string">'all'</span>);
<span class="comment">% Worst-case error when M=33</span>
error3=echart-rest_ech90_3;
wrst_error=max(error3,[],<span class="string">'all'</span>);

<span class="comment">% Message Box with results</span>
msgbox(sprintf(<span class="string">'WRST Error(M=11) = %0.5g \nWRST Error(M=22) = %0.5g \nWRST Error(M=33) = %0.5g'</span><span class="keyword">...</span>
    ,wrst_error1,wrst_error2,wrst_error),<span class="string">'3.2.3b)'</span>)
</pre><img vspace="5" hspace="5" src="LabP9_09.png" alt=""> <img vspace="5" hspace="5" src="LabP9_10.png" alt=""> <img vspace="5" hspace="5" src="LabP9_11.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Lab P-9 - Sampling, Convolution, and FIR Filtering: 3 Lab Exercises (FIR Filters)
% In the following sections we will study how a filter can produce the
% following special effects:
% 1)Echo;
% 2)Deconvolution
%% 3.1 Deconvolution Experiment for 1-D Filters
% Use the function firfilt() to implement the filter 
% $$w[n]=x[n]-0.9x[n-1]$ (3)
% on the input signal x[n] defined.

clear; %<REPLACE_WITH_DASH_DASHclear workspace
close all %<REPLACE_WITH_DASH_DASHclose all figures

% Input signal
xx=255*(rem(0:100,50)<10);
% Filter coefficient
bb=[1 -0.9];
% Compute the output - FIR Filter-1
ww=firfilt(bb,xx);

% 3.1a)********************************************************************
% Plot both the input and output wave forms x[n] and w[n] on the same
% figure, using subplot. Explain why the output appears the way it does by
% figuring out (mathematically) the effect of the filter coefficient.
%**************************************************************************

% Array Indices
first=1;
last=length(xx);
nn=first:last; %<REPLACE_WITH_DASH_DASH use first=1 and last=length(xx)

% Plots
figure(1)
subplot(2,1,1);
stem(first-1:last-1,xx(nn),'LineWidth',2)
xlabel('Time Index (n)','FontSize',16);
ylabel('Input x[n]','FontSize',16);
title('3.1a)Deconv Experiment for 1-D Filters','FontSize',16);
xlim([0 75]);
subplot(2,1,2);
stem(first-1:last-1,ww(nn),'filled','LineWidth',2) %REPLACE_WITH_DASH_DASHMake black dots
xlabel('Time Index (n)','FontSize',16);
ylabel('Output w[n]','FontSize',16);
xlim([0 75]);


% Analysis of results:
% Through the coefficient bb, the process (mathematically) of the filter is
% w[n]= x[n]−0.9*x[n − 1]. 
% w[0]= x[0]−0.9*x[n−1]=255−0= 255; 
% w[1]= x[1]−0.9*x[0]=255−0.9*(255)=25.5 
% w[2:9]=w[1]=25.5 
% w[10]= x[10]−0.9*x[9]=0-0.9*(255)=-229.5; 
% w[11]= x[11]−0.9*x[10]=0-0.9*(0)=0;
% w[12:49]= w[11]=0; 
% Then it starts over as w[0]= 255; 
% Initially, the output of the filter is at 255 and it suddenly declines to
% 25.5 and stay constant till n=10. Moreover, the output go down negative
% and then up to zero.

% 3.1b)********************************************************************
% Note that w[n] and x[n] are not the same length. Determine the length of
% the filtered signal w[n], and explain how it is related to the length of
% x[n] and the length of the FIR filter. (If you need a hint, refer ro
% section 1.2.)
%**************************************************************************

% Calculation
length_x_n=length(xx);
length_w_n=length(ww);

% Message Box with results
msgbox(sprintf('Total Length of x[n] = %0.5g \nTotal Length of w[n] = %0.5g'...
    ,length_x_n,length_w_n),'3.1b)')

% Analysis of results:
% Section 1.2 shows that length(yy) = length(xx)+length(bb)-1,
% Thus, length(ww) = length(xx)+ length(bb)-1


%% 3.1.1 Restoration Filter
% The filter 
% $$y[n]=\sum_{l=0}^{M}r^lw[n-l]$ (FIR Filter-2)
% can be used to undo the effects of the FIR filter in the previous
% section. Use the following steps to show how well it works when r=0.9 and
% M=22.

% 3.1.1a)******************************************************************
% Process the signal w[n] from (3) with FILTER-2 to obtain the output
% signal y[n]
%**************************************************************************

close all %<REPLACE_WITH_DASH_DASHclose all figures

% FIR Filter-2 Variables
r=0.9; M=22; 
% signal y[n]
yy=zeros(length(xx),1);

% Compute the output - FIR Filter-2
yy=firfilt2(ww,yy,r,M);

% 3.1.1b)******************************************************************
% Make stem plots of w[n] and y[n] using a time-index axis n that is the
% same for both signals. Put the stem plot in the same window for
% comparison - using a two-panel subplot.
%**************************************************************************

% Plots
figure(2)
subplot(2,1,1);
stem(first-1:last-1,ww(nn),'r','LineWidth',2)
xlabel('Time Index (n)','FontSize',16);
ylabel('Output w[n]','FontSize',16);
title('3.1.1b) Restoration Filter','FontSize',16);
xlim([0 49]);
hold on
subplot(2,1,2);
stem(first-1:last-1,yy(nn),'r','filled','LineWidth',2) %REPLACE_WITH_DASH_DASHMake black dots
xlabel('Time Index (n)','FontSize',16);
ylabel('y[n] (Restoring x[n])','FontSize',16);
xlim([0 49]);
ylim([min(ww) max(xx)]);
hold off

% 3.1.1c)******************************************************************
% Since the objective of the restoration is to produce y[n] that is almost
% identical to x[n], make a plot of the error (difference) between x[n] and
% y[n] over the range 0<=n<50
%**************************************************************************

% Calculate Error between x[n] and y[n]
error=abs(yy-xx);

% Plots
figure(3)
subplot(2,1,1);
stem(first-1:last-1,xx(nn),'b','LineWidth',2)
hold on
stem(first-1:last-1,yy(nn),'r','LineWidth',2)
xlabel('Time Index (n)','FontSize',16);
ylabel('x[n] and y[n]','FontSize',16);
xlim([0 50]);
title('3.1.1c) Absolute Error between x[n] and y[n]','FontSize',16);
legend('x[n]','y[n]')
subplot(2,1,2);
plot(first-1:last-1,error,'LineWidth',2)
xlabel('Time Index (n)','FontSize',16);
ylabel('\miderror\mid','FontSize',16);
xlim([0 50]);
hold off

%% 3.1.2 Worst Case Error

% 3.1.2a)******************************************************************
% Evaluate the worst-case error by doing the following: use max() function
% to find the maximum of the difference between y[n] and x[n] in the range
% 0 <= n < 50.
%**************************************************************************

close all %<REPLACE_WITH_DASH_DASHclose all figures

% Calculate worst-case error
wrst_error=max(error(1:51)) ;

% Message Box with results
msgbox(sprintf('WRST Error between y[n] & w[n] = %0.5g'...
    ,wrst_error),'3.1.2)')



% 3.1.2b)******************************************************************
% What does the error plot and worst case error tell you about the quality
% of the restoration of x[n]? How small do you think the worst case error
% has to be so that it cannot be seen on a plot?
%**************************************************************************

% Analysis of results:
% The max difference between x[n] and a y[n] is 22.6 (11.24%), which shows
% a mild lack of restoration quality. The output range is 0−256, which it
% shows the error is comparatively small. This displays that output y[n]
% is a good restoration of the input x[n]. A worst-case error less than 0.1
% % would be ideal and hard to spot in the plot.

%% 3.1.3 An Echo Filter
% The following FIR filter can be interpreted as an echo filter.
% $$y1[n]=x1[n]+r*x1[n-P]$ (4).
% Explain why this is a valid interpretation by working out the following:

% 3.1.3a)******************************************************************
% You have an audio signal sampled at fs = 8000 Hz and you would like to
% add a delayed version of the signal to simulate an echo. The time delay
% of the echo should be 0.2 seconds, and the strength of the echo should be
% 90% percent of the original. Determine the values of r and P in (4); make
% P an integer.
%**************************************************************************

close all %<REPLACE_WITH_DASH_DASHclose all figures

% Frequency the audio signal is sampled
fs=8000; %<REPLACE_WITH_DASH_DASHHz
% Time Delay
delay=0.2;  %<REPLACE_WITH_DASH_DASHs

% Calculations of P and r
Ts=1/fs;
P=delay/Ts;
r=0.9;

% 3.1.3b)******************************************************************
% Describe the filter coefficients of this FIR filter, and determine its
% length.
%**************************************************************************

% FIR filter coefficient
bb2=[1; zeros(P-2,1); r]';
% FIR filter length
length_FIR=length(bb2);
% Message Box with results
msgbox(sprintf('FIR Filter coefficients are shown on Matlab code \nlength_FIR = %0.5g '...
    ,length_FIR),'3.1.3b)')

% 3.1.3c)******************************************************************
% Implement the echo filter in (4) with the values of r and P determined in
% part (a). Use the speech signal in the vector x2 found in the file
% labdat.mat. Listen to the result to verify that you have produced an
% audible echo.
%**************************************************************************

% BELOW SECTION HAS BEEN COMMENTED OUT FOR PUBLISHING PURPOSE.
% % Load file labdat.mat to get speech signal x2
% load labdat;
% % Compute the output - FIR Filter (4) - Audio with Echo
% y1=firfilt(bb2,x2);
% % Listen to Original Audio
% waitfor(msgbox("Click 'OK' to listen to Original Speech Audio","3.1.3c)"))
% sound(x2)
% pause(4)
% % Listen to Audio with Echo
% waitfor(msgbox("Click 'OK' to listen to Speech Audio with Ech..." + ...
%     "o - created... with FIR Filter (4)","3.1.3c)"))
% % pause
% sound(y1)

%% 3.2 Cascading Two Systems
% More complicated systems are often made up from simple building blocks.
% In the system of Fig 3. two FIR filters are connected "in cascade". For
% this session, assume that the filters in Fig. 3 are described by the two
% equations:
% $$w[n]=x[n]-q*x[n-1]$ (FIR Filter-1) ,
% $$y[n]=\sum_{l=0}^{M}r^lw[n-l]$ (FIR Filter-2)

%% 3.2.1 Overall Impulse Response

% 3.2.1a)******************************************************************
% (a)	Implement the system in Fig. 3 using MATLAB to get the impulse
% response of the overall cascaded system for the case where q = 0.9, r =
% 0.9 and M = 22. Use two calls to firfilt(). Plot the impulse response of
% the overall cascaded system.
%**************************************************************************

clear; %<REPLACE_WITH_DASH_DASHclear workspace
close all %<REPLACE_WITH_DASH_DASHclose all figures

% Overall Impulse Response - Variables
xx=zeros(51,1); %<REPLACE_WITH_DASH_DASHInput Array
xx(1)=1; %<REPLACE_WITH_DASH_DASHImpulse
hh=zeros(length(xx),1); %<REPLACE_WITH_DASH_DASHImpulse Response
% Filter Filter-1 Coef.
bb=[1 -0.9];
% FIR Filter-2 Variables
r=0.9; M=22; 

% Impulse response of the System
hh=firfilt2(firfilt(bb,xx),hh,r,M);

% Array Indices
first=1;
last=length(xx);
nn=first:last; %<REPLACE_WITH_DASH_DASH use first=1 and last=length(xx)

% Plots
figure(4)
stem(first-1:last-1,hh(nn),'LineWidth',2)
xlabel('Time Index (n)','FontSize',16);
ylabel('Impulse Response h[n]','FontSize',16);
title('3.2.1a)Overall Impulse Response, M=22','FontSize',16);

% 3.2.1b)******************************************************************
% Work out the impulse response h(n) of the cascaded system by hand to
% verify that your MATLAB result in part (a) is correct. (Hint: consult old
% Homework problems.)
%**************************************************************************

% Verification of the Results
%w[0]=x[0]-0.9x[0-1]=1
%w[1]=x[1]-0.9x[0]=-0.9
%w[2]=x[2]-0.9x[1]=0
%w[3]=x[3]-0.9x[2]=0
%.
%.
%.
%w[22]=x[22]-0.9w[21]=0
%
%y[0]=0.9^0w[0]+0.9^1w[-1]+0.9^2w[-2]+0.9^3w[-3]+...+0.9^22w[-22]=1
%y[1]=0.9^0w[1]+0.9^1w[0]+0.9^2w[-1]+0.9^3w[-2]+...+0.9^22w[-21]=0
%y[2]=0.9^0w[2}+0.9^1w[1]+0.9^2w[0]+0.9^3w[-1]+...+0.9^22w[-20]=0
%y[3]=0.9^0w[3]+0.9^1w[2]+0.9^2w[1]+0.9^3w[0]+...+0.9^22w[-19]=0
%.
%.
%.
%y[22]=0.9^0w[22]+0.9^1w[21]+0.9^2w[20]+...0.9^21w[1]+0.9^22w[0]=0
%y[23]=0.9^0w[23]+0.9^1w[22]+0.9^2w[21]+0.9^3w[20]+...+0.9^22w[1]=-0.088629
%y[24]=0.9^0w[24]+0.9^1w[23]+0.9^2w[23]+0.9^3w[21]+...+0.9^22w[2]=0
%y[25]=0
%y[26]=0
%.
%.
%.
%As we can see the numbers match with our MATLAB result. 

% 3.2.1c)******************************************************************
% In a deconvolution application, the second system (FIR FILTER-2) tries to
% undo the convolutional effect of the first. Perfect deconvolution would
% require that the cascade combination of the two systems be equivalent to
% the identity system: y[n]=x[n]. If the impulse responses of the two
% systems are h1(n)and h2(n), state the condition on h1[n]*h2[n] to
% achieve perfect deconvolution.
%**************************************************************************

% Analysis
% Deconvolution is the process of filtering a signal to compensate for an
% undesired convolution. Undesired convolution can be: blurried images
% (ghosts), echoes in audio, etc. 
% In our case here, to achieve perfect deconvolution y[n]=x[n]. To extract
% the original signal, the deconvolution filter (FIR FILTER-2) must undo
% the amplitude and phase changes caused by FIR FILTER-1. Thus, the whole
% system, which includes FIR FILTER-1 AND FIR FILTER-2 in cascade, would
% have no overall effect on the input. What that mean is that h1[n]*h2[n]
% needs to be equals to DELTA for that to be true. Theoretically, this can
% be achieved if the right coefficients in each filter are adequate,
% however this becomes not so realistic in real world application since
% there are always unknowns such as electronic noise, temperature drift, or
% variation between devices.
%% 3.2.2 Distorting and Restoring Images
% If we pick 'q' to be a little less than 1.0, then the first system (FIR
% FILTER-1) will cause distortion when applied to the rows and columns of
% an image. The objective in this section is to show that we can use the
% second system (FIR FILTER-2) to undo this distortion (more or less).
% Since FIR FILTER-2 will try to undo the convolutional effect of the
% first, it acts as a deconvolution operator.

% 3.2.2a)******************************************************************
% Load in the image echart.mat with the load command. It creates a matrix
% called echart.
%**************************************************************************

close all %<REPLACE_WITH_DASH_DASHclose all figures

% Load image echart.mat 
load echart.mat;

% 3.2.2b)******************************************************************
% Pick q=0:9 in FILTER-1 and filter the image echart in both directions:
% apply FILTER-1 along the horizontal direction and then filter the
% resulting image along the vertical direction also with FILTER-1. Call the
% result ech90.
%**************************************************************************

% Distorting and Restoring Images Variables
ech90=zeros(length(echart));
% FIR Filter-1 coefficient
bb=[1 -0.9];

% Applying FIR Filter-1
for i=1:length(ech90)
ech90(i,:)=firfilt(bb,echart(i,:));
end


% 3.2.2c)******************************************************************
% Deconvolve ech90 with FIR FILTER-2, choosing M = 22 and r = 0.9. Describe
% the visual appearance of the output, and explain its features by invoking
% your mathematical understanding of the cascade filtering process. Explain
% why you see “ghosts” in the output image, and use some previous
% calculations to determine how big the ghosts (or echoes) are, and where
% they are located. Evaluate the worst-case error in order to say how big
% the ghosts are relative to “black-white” transitions which are 0 to 255.
%**************************************************************************

% Distorting and Restoring Images Variables
[m,n]=size(echart);
rest_ech90=zeros(m,n);
% FIR Filter-2 Variables
r=0.9; M=22; 

% Applying FIR Filter-2 (Restoring)
for i=1:length(ech90)
rest_ech90(i,:)=firfilt2(ech90(i,:),rest_ech90(i,:),r,M);
end

% Check Image Processing
figure(5)
subplot(1,3,1)
imshow(echart,[])
title('Original Image')
subplot(1,3,2)
imshow(ech90,[])
title('After FIR-1 ')
subplot(1,3,3)
imshow(rest_ech90,[])
title('After FIR-2 - Restored Image, M=22')
sgtitle("Image processing - Figure 3",'FontSize',16);

% Analysis of results: 
% Looking at the restored image, we conclude that it has plausible been
% restored, however it presents "ghosts/echoes". The reason of the echoes
% can be explained looking at the impulse response of the whole system.
% The impulse response is echoed after n=23, with a value of -0.089. This
% corresponds to -8.9% in the gray scale [0 - 255].
% In the gray scaled image, we can predict the worst error (with a FIR Filter-2 (M=22)
% to be 255*8.86294% = 22.6. Furthermore, each pixel will echo with
% -8.86% of the pixel value [0 - 255] at n=23 forward.
% Later on on the lab, we will see the influence of varying the value of FIR
% Filter-2 'M' variable.


%% 3.2.3 A Second Restoration Experiment 

% 3.2.3a)******************************************************************
% Now try to deconvolve ech90 with several different FIR filters for
% FILTER-2. You should set r = 0:9 and try several values for M such as 11,
% 22 and 33. Pick the best result and explain why it is the best. Describe
% the visual appearance of the output, and explain its features by invoking
% your mathematical understanding of the cascade filtering process. HINT:
% determine the impulse response of the cascaded system and relate it to
% the visual appearance of the output image. Hint: you can use dconvdemo to
% generate the impulse responses of the cascaded systems, like you did in
% the Warm-up.
%**************************************************************************

close all %<REPLACE_WITH_DASH_DASHclose all figures

% A second restoration experiment variables
rest_ech90_2=zeros(m,n); % <REPLACE_WITH_DASH_DASHRestoration Array 2 (M2=11)
rest_ech90_3=zeros(m,n); % <REPLACE_WITH_DASH_DASHRestoration Array 3 (M3=33)
hh2=zeros(length(xx),1);hh3=zeros(length(xx),1);%<REPLACE_WITH_DASH_DASHImpulse Response Arrays
% FIR Filter-2 Variables (different tests)
r=0.9; M2=11; M3=33;

% Applying FIR Filter-2, M=11 (Restoring)
for i=1:length(ech90)
rest_ech90_2(i,:)=firfilt2(ech90(i,:),rest_ech90_2(i,:),r,M2);
rest_ech90_3(i,:)=firfilt2(ech90(i,:),rest_ech90_3(i,:),r,M3);
end

figure(6)
subplot(1,3,1)
imshow(rest_ech90_2,[])
title('Restored Image, M=11')
subplot(1,3,2)
imshow(rest_ech90,[])
title('Restored Image, M=22')
subplot(1,3,3)
imshow(rest_ech90_3,[])
title('Restored Image,M=33')
sgtitle("Restored images with different M values(FIR Filter-2)",'FontSize',16);


% Analysis of results: 
% It is clear that the best restoration happens when we choose a higher M,
% M=33. With a higher M, there are more # of summations for each FIR
% FILTER-2 output calculation. This minimizes the worst error (pixel
% comparisson between original and restored images). It is also predictable
% that the higher the M is, the higher echoed delay the image will have. We
% check this from the impulse response of the system with different 'M'
% values.
% Let's analyze the impulse response  in each case to prove
% the concept, when:
% I) M=11 
% II) M=33.


% Impulse response of the Systems
hh2=firfilt2(firfilt(bb,xx),hh2,r,M2);
hh3=firfilt2(firfilt(bb,xx),hh3,r,M3);

% Array Indices
first=1;
last=length(xx);
nn=first:last; %<REPLACE_WITH_DASH_DASH use first=1 and last=length(xx)

% Plots
figure(7)
subplot(3,1,1)
stem(first-1:last-1,hh2(nn),'b','LineWidth',2)
xlabel('Time Index (n)','FontSize',16);
ylabel('h[n], M=11','FontSize',16);
% xlim([0 25]);
title(['3.2.3a) Imp Response - different M values' ...
    '(FIR-Filter-2)'],'FontSize',16);
legend('M=11');
subplot(3,1,2)
stem(first-1:last-1,hh(nn),'r','LineWidth',2)
xlabel('Time Index (n)','FontSize',16);
ylabel('h[n], M=22','FontSize',16);
% xlim([0 25]);
legend('M=22');
subplot(3,1,3)
stem(first-1:last-1,hh3(nn),'g','LineWidth',2)
xlabel('Time Index (n)','FontSize',16);
ylabel('h[n], M=33','FontSize',16);
% xlim([0 25]);
legend('M=33');

% 3.2.3b)******************************************************************
% Furthermore, when you consider that a gray-scale display has 256 levels,
% how large is the worst-case error (from the previous part) in terms of
% number of gray levels? Do this calculation for each of the three filters
% in part (a). Think about the following question: “Can your eyes perceive
% a gray scale change of one level, i.e., one part in 256?”
%**************************************************************************

% Calculation of worst cases

% Worst-case error when M=11
error1=echart-rest_ech90_2;
wrst_error1=max(error1,[],'all');
% Worst-case error when M=22
error2=echart-rest_ech90;
wrst_error2=max(error2,[],'all');
% Worst-case error when M=33
error3=echart-rest_ech90_3;
wrst_error=max(error3,[],'all');

% Message Box with results
msgbox(sprintf('WRST Error(M=11) = %0.5g \nWRST Error(M=22) = %0.5g \nWRST Error(M=33) = %0.5g'...
    ,wrst_error1,wrst_error2,wrst_error),'3.2.3b)')
##### SOURCE END #####
--></body></html>